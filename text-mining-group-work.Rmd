---
title: "text-mining-group-work"
author: "Vladyslav Gorbunov, Larissa Pagliarin"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: "hpstr" 
  html_document:
    toc: true
    toc_float: true
---

## Data Import and Preparation

We Import the dataset *SP500_data.csv* and make a copy to work with it and named it *data*. We copy it so we can be secure that i do not make any changes in the original dataset.
<br>
We use several libraries to process the tasks and get the output that is asked.


```{r library, include=FALSE}
# Load packages and libraries, if not already available.
libraries = c("ggplot2", "knitr", "dplyr", "tidyverse", "lubridate", "tm", "wordcloud", "SnowballC", "text", "remotes", "plotly")

lapply(libraries, function(x) if (!(x %in% installed.packages())) {
  install.packages(x)
})

lapply(libraries, library, quietly = TRUE, character.only = TRUE)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r data, include=FALSE}
# Load data set and make a copy of the original
options(scipen=999)
Tweets_all <- load("Tweets_all.rda")
```

<br>

## Data Exploration

This section gives a concise view of the Tweets on the Swiss Univerity Social Media accounts data.
<br>
The dataset consists 19'575 observations and 14 variables:
<br>
<br>

**Time Range and Tweet Frequency:**
<br>

- Tweets are from September 29, 2009, to January 26, 2023 and this indicates a long-term use of Twitter
- The median tweet date is April 13, 2018, suggesting that half of the tweets were posted after this date and the data is skewed
<br>

*Retweet and Favorite Counts:**
<br>

- The data shows a minimum of 0 and a maximum of 267 retweets and 188 likes per tweet
- the median and first quartile for retweets and likes are 0, indicating that many tweets receive little to no engagement
- The `in_reply_to_screen_name` field suggests that some tweets are responses to other users, which might indicate engagement or conversation strategies used by the university
<br>

**ID and String Variables:**
<br>
- The `id` and `id_str` fields are technical identifiers for tweets, indicating that tweets have been collected over a wide range of tweet
<br>

**Language and University Fields:**
<br>

- The `lang` shows the common language used at the university 
- `university` shows the abbreviation of the university
<br>

**Temporal Patterns:**
<br>

- `created_at`, `tweet_date`, `tweet_hour`, and `tweet_month` provide detailed temporal data
- can be analyzed to understand peak times of activity and seasonal or monthly trends in tweeting behavior.
<br>

**Content Analysis**
<br>

The word cloud represents the most frequently used words in the filtered tweets with high engagement (likes or retweets). Key observations include:

Frequent Terms: Larger words such as "bachelor," "design," "die," "das," "der," and "amp" indicate their higher occurrence.
Key Topics:
"bachelor" for Bachelor's programs or graduates.
"design" related to design courses or projects.
"HSLU" (Hochschule Luzern).
General terms: "schweiz," "zeigen," "nicht."
Note: The term "amp" appears due to HTML encoding and is not meaningful.


<br>
```{r}
# Display first six rows of 'tweets'
head(tweets)

# Provide summary statistics
summary(tweets)
```

## Data Manipulation

### Languages

Here we calculate the frequency of each language present in the tweets dataset and sorts these frequencies in descending order. 
<br>
The output indicates that German (de) is the most common language with 14,474 occurrences, followed by Italian (it) with 1,865 and French (fr) with 1,792. English (en) comes next with 1,280 tweets. The frequencies of other languages, including rare and less commonly used ones, are also listed, showcasing the linguistic diversity in the dataset.

```{r}
# Count the frequency of each language
lang_counts <- table(tweets$lang)

# Sort the language frequencies in descending order
sort(lang_counts, decreasing = TRUE)
```

<br>
Due to the fact that German, Italian, French and English are the most frequently listed languages and other languages are not used in large numbers and are not among the most spoken languages in Switzerland, we limit the data set to the 4 most important ones.

```{r}
# Filter the DataFrame to keep only tweets in German, Italian, French and English
filtered_tweets <- tweets[tweets$lang %in% c("de", "it", "fr", "en"), ]

# Check the resulting language distribution
table(filtered_tweets$lang)
```
<br>

This gives us the new Summeray of the data set:
<br>

- **Number of Records:** The total count of tweets has decreased from 19,575 to 19,411, indicating some tweets have been removed or filtered out.
- **Date and Time:** Minimal changes are reflected across the median and mean values.
- **Other Attributes:** No significant changes are observed in the ranges.

```{r}
# Provide summary statistics
summary(filtered_tweets)
```

### Emojis

The package `emo` is used for emoji analysis in R, which is essential for text data that includes emojis. This is useful for cleaning data, extracting information, or preparing text for further analysis.
<br>
Understanding the prevalence of emojis can help analyze sentiment, user engagement, or cultural trends in social media data.

```{r}
# Install the emo package from GitHub for Emoji analyzes
if (!require("emo")) {
  remotes::install_github("hadley/emo")
}
library(emo)
```

```{r include=FALSE}
# check for the presence of any emojis and tabulates the results.
table(ji_detect(filtered_tweets$full_text))

# Example for replacing emojis with "[EMOJI]"
filtered_tweets$clean_text <- sapply(filtered_tweets$full_text, function(text) {
  ji_replace_all(text, replacement = "[EMOJI]")
})

# Extract emojis first
filtered_tweets$emojis <- sapply(filtered_tweets$full_text, ji_extract_all)
```



### Text Preprocessing

We create a text corpus from `filtered_tweets$clean_text`, where each tweet is treated as a separate document. 
<br>
The corpus serves as the foundational structure for text analysis, allowing for uniform processing and manipulation of the text data.

```{r}
# Corpus: Collection of text documents that generally serves as a basis for analysis in text processing and text mining.
# VectorSource(tweets): This vector is then used as the source for the corpus, whereby each entry in the vector becomes a separate document in the corpus.
# It is important that the text is extracted, as the corpus should only work with text data.
corpus <- Corpus(VectorSource(filtered_tweets$clean_text))
```

<br>
Here we clean the corpus by converting all text to lowercase, removing punctuation, numbers, and stopwords from German, French, Italian, and English, and finally stripping extra spaces.
<br>
Cleaning the text is crucial for reducing noise and focusing analyses on meaningful words only. This standardizes the text data, making subsequent analyses like topic modeling or sentiment analysis more effective and less prone to error due to textual inconsistencies.

```{r}
# Clean text
corpus <- tm_map(corpus, content_transformer(tolower))  # Convert to lower case
corpus <- tm_map(corpus, removePunctuation)             # Removing punctuation marks
corpus <- tm_map(corpus, removeNumbers)                 # Removing numbers
corpus <- tm_map(corpus, removeWords, stopwords("german"))  # Removing stop words
corpus <- tm_map(corpus, removeWords, stopwords("french"))
corpus <- tm_map(corpus, removeWords, stopwords("italian"))
corpus <- tm_map(corpus, removeWords, stopwords("english"))
corpus <- tm_map(corpus, stripWhitespace)               # Removal of additional spaces
corpus <- tm_map(corpus, stemDocument) #remove suffixes, etc.; only root form of the word

# Further clean the text by removing specific web/text symbols and terms
corpus <- tm_map(corpus, content_transformer(function(x) {
  x <- gsub("–", "", x)
  x <- gsub("…", "", x) 
  x <- gsub("«", "", x) 
  x <- gsub("»", "", x) 
  x <- gsub("\\b(rt|www|emojiemoji)\\b", "", x, ignore.case = TRUE)  # Remove 'rt', 'www', and 'emojiemoji'
  x <- gsub("amp", "", x, ignore.case = TRUE)  # Remove 'amp' from HTML encoded '&'
  x <- gsub("http[s]?://\\S+", "", x)  # Remove URLs
  return(x)
}))
```

<br>
Here we create a Document-Term Matrix (DTM) from the corpus, applying additional filters like punctuation removal and stopping word exclusion during the matrix formation. Then, it filters out terms that appear in less than 1% of the documents to reduce sparsity.
<br>
Reducing sparsity helps focus on terms that have significant presence across documents, enhancing the reliability and performance of statistical models and algorithms applied later.

```{r}
# Create DTM and remove sparse terms
dtm1 <- DocumentTermMatrix(corpus, control = list(removePunctuation = TRUE, stopwords = TRUE, wordLengths = c(1, Inf)))
dtm1 <- removeSparseTerms(dtm1, sparse = 0.99)  # Adjust sparsity threshold as needed
```


## Tweet Analysis

### Frequency

The function returns a vector of terms that meet the specified frequency threshold. In this case, terms such as "schweizer", "bfh", "neuen", "emoji", and others are listed, indicating they are common within the dataset. By setting a high frequency threshold (e.g., 25 occurrences), you can focus on terms that are more relevant across the dataset.

```{r}
# Check the term frequencies
findFreqTerms(dtm1, lowfreq = 25)  # Shows terms that occur at least 25 times
```

<br>

Words like "schweizer" (Swiss), "unternehmen" (companies), "zukunft" (future), "innov" (innovation), and "digital" suggest that the text data heavily revolves around themes of Swiss companies, innovation, and digital advancements.
<br>
Frequent appearance of terms like "dank" (thanks), "neue" (new), "mehr" (more), and "info" indicate common communication patterns possibly related to news dissemination or updates about new developments and initiatives.

```{r warning=FALSE}
# Ensure word names are captured
word_freq1 <- sort(rowSums(as.matrix(dtm1)), decreasing = TRUE)
top_word_freq1 <- head(word_freq1, 80)
word_names1 <- colnames(dtm1)

# Generate word cloud using the correct word names
wordcloud(
  words = word_names1, 
  freq = top_word_freq1, 
  max.words = 80,
  scale = c(4, 0.5),       # Control for size of the most and least frequent words
  random.order = FALSE,    # Higher frequency words appear first
  rot.per = 0.25,          # Allows some rotation for fitting
  colors = brewer.pal(8, "Dark2")  # Enhances visual appeal
)
```



```{r, fig.width=15, fig.height=10}
# Code to analyze tweet frequencies by time and university
p1<- filtered_tweets %>%
  mutate(tweet_month = floor_date(created_at, "month")) %>%
  group_by(university, tweet_month) %>%
  summarize(count = n(), .groups = 'drop') %>%
  ggplot(aes(x = tweet_month, y = count, fill = university)) +
  geom_col(position = "dodge") +
  theme_minimal() +
  labs(title = "Monthly Tweet Frequency by University", x = "Year", y = "Number of Tweets")

# Convert to interactive plotly object
interactive_plot <- ggplotly(p1, tooltip = "text")

# Optionally, add configurations to enhance interaction
interactive_plot <- interactive_plot %>% layout(
  hovermode = 'closest',
  title = "Click on a University to see its Tweet Trends",
  showlegend = TRUE
)

interactive_plot
```



## High Engagement


This section sets a variable `engagement_threshold` to 20, which is used as the minimum number of likes or retweets a tweet must have to be considered as having "high engagement". This threshold helps to focus on tweets that have garnered more attention and interaction.

```{r}
# Set a threshold for "high engagement" (e.g., tweets with at least 20 likes or retweets)
engagement_threshold <- 20

# Filter tweets based on this engagement threshold
high_engagement_tweets <- filtered_tweets %>%
  filter(favorite_count >= engagement_threshold | retweet_count >= engagement_threshold)
```


<br>

Also for the `high_engagement_tweets` we clean the corpus by converting all text to lowercase, removing punctuation, numbers, and stopwords from German, French, Italian, and English, and finally stripping extra spaces and we create a Document-Term Matrix (DTM) from this corpus.


```{r warning=FALSE}
# Rebuild the corpus with the sampled data
corpus2 <- Corpus(VectorSource(high_engagement_tweets$clean_text)) 

corpus2 <- tm_map(corpus2, content_transformer(tolower))  # Convert to lower case
corpus2 <- tm_map(corpus2, removePunctuation)             # Removing punctuation marks
corpus2 <- tm_map(corpus2, removeNumbers)                 # Removing numbers
corpus2 <- tm_map(corpus2, removeWords, stopwords("german"))  # Removing stop words
corpus2 <- tm_map(corpus2, removeWords, stopwords("french"))
corpus2 <- tm_map(corpus2, removeWords, stopwords("italian"))
corpus2 <- tm_map(corpus2, removeWords, stopwords("english"))
corpus2 <- tm_map(corpus2, stripWhitespace)               # Removal of additional spaces
corpus2 <- tm_map(corpus2, stemDocument) #remove suffixes, etc.; only root form of the word

# Further clean the text by removing specific web/text symbols and terms
corpus2 <- tm_map(corpus2, content_transformer(function(x) {
  x <- gsub("–", "", x)
  x <- gsub("…", "", x) 
  x <- gsub("«", "", x) 
  x <- gsub("»", "", x) 
  x <- gsub("\\b(rt|www|emojiemoji)\\b", "", x, ignore.case = TRUE)  # Remove 'rt', 'www', and 'emojiemoji'
  x <- gsub("amp", "", x, ignore.case = TRUE)  # Remove 'amp' from HTML encoded '&'
  x <- gsub("http[s]?://\\S+", "", x)  # Remove URLs
  return(x)
}))

# Create DTM and remove sparse terms
dtm <- DocumentTermMatrix(corpus2, control = list(removePunctuation = TRUE, stopwords = TRUE, wordLengths = c(1, Inf)))
dtm <- removeSparseTerms(dtm, sparse = 0.99)  # Adjust sparsity threshold as needed
```

<br>

The word cloud effectively illustrates which topics are most engaging within the parameter for at least 20 likes or retweets. This visualization can help in refining the communication and engagement strategies by focusing on the topics that naturally engage your audience.
<br>

- The word cloud highlights Words like "digital," "Data," and "Open" emphasize a strong focus on digital innovation and open data or technology. This suggests that tweets discussing digital technologies or data transparency tend to receive higher engagement.
- Terms such as "forscherteam" (research team), "univers" (universities), and "lab" indicate that the content related to academic research or laboratory work resonates well with the audience. This could be within a university setting or tech-related academic research.
- Words like "revolutionieren" (revolutionize), "entwickelt" (developed), and "chanc" (chances) suggest discussions around innovation and development are highly engaging.
- "Gespräch" (conversation/discussion) indicates that interactive or discussion-based tweets, perhaps those inviting comments or thoughts from the community, are among those that receive more likes and retweets.
- Words like "mithilf" (with help) and phrases possibly related to collaboration highlight the community.

```{r warning=FALSE}
# Ensure word names are captured
word_freq <- sort(rowSums(as.matrix(dtm)), decreasing = TRUE)
top_word_freq <- head(word_freq, 80)
word_names <- colnames(dtm)

# Generate word cloud using the correct word names
wordcloud(
  words = word_names, 
  freq = top_word_freq, 
  max.words = 80,
  scale = c(4, 0.5),       # Control for size of the most and least frequent words
  random.order = FALSE,    # Higher frequency words appear first
  rot.per = 0.25,          # Allows some rotation for fitting
  colors = brewer.pal(8, "Dark2")  # Enhances visual appeal
)
```


### Engagement Analysis



```{r}
# Analysis of likes and retweets
filtered_tweets %>%
  group_by(university) %>%
  summarize(total_likes = sum(favorite_count), total_retweets = sum(retweet_count), .groups = 'drop') %>%
  ggplot(aes(x = reorder(university, total_likes), y = total_likes)) +
  geom_col() +
  coord_flip() +
  labs(title = "Engagement Analysis by University", x = "University", y = "Total Likes")
```



## Recommendations




## Conclusion
























